#include <stm32f4xx_ll_gpio.h>
#include <stm32f4xx_ll_utils.h>
#include "ov2640.h"
#include "sccb.h"

// 初始化参数
static const uint8_t g_ppu8Init[][2] = {
    {0xFF, 0x00}, {0x2C, 0xFF}, {0x2E, 0xDF}, {0xFF, 0x01}, {0x3C, 0x32}, {0x11, 0x00}, {0x09, 0x02}/*, {0x04, 0xD8}*//* 水平/垂直镜像 */,
    {0x13, 0xE5}, {0x14, 0x48}, {0x2C, 0x0C}, {0x33, 0x78}, {0x3A, 0x33}, {0x3B, 0xFB}, {0x3E, 0x00}, {0x43, 0x11},
    {0x16, 0x10}, {0x39, 0x92}, {0x35, 0xDA}, {0x22, 0x1A}, {0x37, 0xC3}, {0x23, 0x00}, {0x34, 0xC0}, {0x36, 0x1A},
    {0x06, 0x88}, {0x07, 0xC0}, {0x0D, 0x87}, {0x0E, 0x41}, {0x4C, 0x00}, {0x48, 0x00}, {0x5B, 0x00}, {0x42, 0x03},
    {0x4A, 0x81}, {0x21, 0x99}, {0x24, 0x40}, {0x25, 0x38}, {0x26, 0x82}, {0x5C, 0x00}, {0x63, 0x00}, {0x46, 0x00},
    {0x0C, 0x3C}, {0x61, 0x70}, {0x62, 0x80}, {0x7C, 0x05}, {0x20, 0x80}, {0x28, 0x30}, {0x6C, 0x00}, {0x6D, 0x80},
    {0x6E, 0x00}, {0x70, 0x02}, {0x71, 0x94}, {0x73, 0xC1}, {0x3D, 0x34}, {0x5A, 0x57}, {0x12, 0x00}/* UXGA 1600*1200 */, {0x17, 0x11},
    {0x18, 0x75}, {0x19, 0x01}, {0x1A, 0x97}, {0x32, 0x36}, {0x03, 0x0F}, {0x37, 0x40}, {0x4F, 0xCA}, {0x50, 0xA8},
    {0x5A, 0x23}, {0x6D, 0x00}, {0x6D, 0x38}, {0xFF, 0x00}, {0xE5, 0x7F}, {0xF9, 0xC0}, {0x41, 0x24}, {0xE0, 0x14},
    {0x76, 0xFF}, {0x33, 0xA0}, {0x42, 0x20}, {0x43, 0x18}, {0x4C, 0x00}, {0x87, 0xD5}, {0x88, 0x3F}, {0xD7, 0x03},
    {0xD9, 0x10}, {0xD3, 0x82}, {0xC8, 0x08}, {0xC9, 0x80}, {0x7C, 0x00}, {0x7D, 0x00}, {0x7C, 0x03}, {0x7D, 0x48},
    {0x7D, 0x48}, {0x7C, 0x08}, {0x7D, 0x20}, {0x7D, 0x10}, {0x7D, 0x0E}, {0x90, 0x00}, {0x91, 0x0E}, {0x91, 0x1A},
    {0x91, 0x31}, {0x91, 0x5A}, {0x91, 0x69}, {0x91, 0x75}, {0x91, 0x7E}, {0x91, 0x88}, {0x91, 0x8F}, {0x91, 0x96},
    {0x91, 0xA3}, {0x91, 0xAF}, {0x91, 0xC4}, {0x91, 0xD7}, {0x91, 0xE8}, {0x91, 0x20}, {0x92, 0x00}, {0x93, 0x06},
    {0x93, 0xE3}, {0x93, 0x05}, {0x93, 0x05}, {0x93, 0x00}, {0x93, 0x04}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
    {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00}, {0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02},
    {0x97, 0x0C}, {0x97, 0x24}, {0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98}, {0x97, 0x80},
    {0x97, 0x00}, {0x97, 0x00}, {0xC3, 0xEF}, {0xA4, 0x00}, {0xA8, 0x00}, {0xC5, 0x11}, {0xC6, 0x51}, {0xBF, 0x80},
    {0xC7, 0x10}, {0xB6, 0x66}, {0xB8, 0xA5}, {0xB7, 0x64}, {0xB9, 0x7C}, {0xB3, 0xAF}, {0xB4, 0x97}, {0xB5, 0xFF},
    {0xB0, 0xC5}, {0xB1, 0x94}, {0xB2, 0x0F}, {0xC4, 0x5C}, {0xC0, 0xC8}, {0xC1, 0x96}, {0x8C, 0x00}, {0x86, 0x3D},
    {0x50, 0x89}/* DSP缩放 */, {0x51, 0x90}, {0x52, 0x2C}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88}, {0x5A, 0x90}, {0x5B, 0x2C},
    {0x5C, 0x05}, {0xD3, 0x02}/* 自动设置 */, {0xC3, 0xED}, {0x7F, 0x00}, {0xDA, 0x09}, {0xE5, 0x1F}, {0xE1, 0x67}, {0xE0, 0x00},
    {0xDD, 0x7F}, {0x05, 0x00}
};
// 图像模式参数
static const uint8_t g_ppu8RGB565[][2] = {
    {0xFF, 0x00}, {0xDA, 0x09}, {0xD7, 0x03}, {0xDF, 0x02}, {0x33, 0xA0}, {0x3C, 0x00}, {0xE1, 0x67}, {0xFF, 0x01},
    {0xE0, 0x00}, {0xE1, 0x00}, {0xE5, 0x00}, {0xD7, 0x00}, {0xDA, 0x00}, {0xE0, 0x00}
};
static const uint8_t g_ppu8YUV422[][2] = {
    {0xFF, 0x00}, {0xDA, 0x10}, {0xD7, 0x03}, {0xDF, 0x00}, {0x33, 0x80}, {0x3C, 0x40}, {0xE1, 0x77}, {0x00, 0x00}
};
static const uint8_t g_ppu8JPEG[][2] = {
    {0xFF, 0x01}, {0xE0, 0x14}, {0xE1, 0x77}, {0xE5, 0x1F}, {0xD7, 0x03}, {0xDA, 0x10}, {0xE0, 0x00}
};
// 自动曝光参数
static const uint8_t g_ppu8AutoExposure[5][6] = {
    {0x24, 0x20, 0x25, 0x18, 0x26, 0x60}, {0x24, 0x34, 0x25, 0x1C, 0x26, 0x00}, {0x24, 0x3E, 0x25, 0x38, 0x26, 0x81},
    {0x24, 0x48, 0x25, 0x40, 0x26, 0x81}, {0x24, 0x58, 0x25, 0x50, 0x26, 0x92}
};
// 白平衡参数
static const uint8_t g_ppu8WhiteBalance[4][6] = {
    {0xCC, 0x5E, 0xCD, 0x41, 0xCE, 0x54}, {0xCC, 0x65, 0xCD, 0x41, 0xCE, 0x4F}, {0xCC, 0x52, 0xCD, 0x41, 0xCE, 0x66},
    {0xCC, 0x42, 0xCD, 0x3F, 0xCE, 0x71}
};
// 对比度参数
static const uint8_t g_ppu8Contrast[5][2] = {
    {0x18, 0x34}, {0x1C, 0x2A}, {0x20, 0x20}, {0x24, 0x16}, {0x28, 0x0C}
};
// 效果参数
static const uint8_t g_ppu8Effect[7][3] = {
    {0x00, 0x80, 0x80}, {0x40, 0x80, 0x80}, {0x18, 0x80, 0x80}, {0x18, 0x40, 0xC0}, {0x18, 0x40, 0x40}, {0x18, 0xA0, 0x40},
    {0x18, 0x40, 0xA6}
};

cam_err_e camInit(camSettings *camsInit) {
    sccbSettings sccbsInit;
    sccbsInit.u8Addr = OV2640_ADDR;
    sccbsInit.SCL_GPIO_Port = camsInit->SCL_GPIO_Port;
    sccbsInit.SDA_GPIO_Port = camsInit->SDA_GPIO_Port;
    sccbsInit.SCL_Pin = camsInit->SCL_Pin;
    sccbsInit.SDA_Pin = camsInit->SDA_Pin;
    sccbInit(&sccbsInit);
    LL_GPIO_ResetOutputPin(camsInit->PDN_GPIO_Port, camsInit->PDN_Pin);
    LL_mDelay(10);
    LL_GPIO_ResetOutputPin(camsInit->RST_GPIO_Port, camsInit->RST_Pin);
    LL_mDelay(10);
    LL_GPIO_SetOutputPin(camsInit->RST_GPIO_Port, camsInit->RST_Pin);
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x1);
    sccbWriteReg(OV2640_SENSOR_COM7, 0x80);
    LL_mDelay(50);
    if ((sccbReadReg(OV2640_SENSOR_MIDH) << 8 | sccbReadReg(OV2640_SENSOR_MIDL)) != OV2640_MID) return CAM_ERR_MISMATCHING_MID;
    if ((sccbReadReg(OV2640_SENSOR_PIDH) << 8 | sccbReadReg(OV2640_SENSOR_PIDL)) != OV2640_PID) return CAM_ERR_MISMATCHING_PID;
    for (uint8_t i = 0; i < sizeof(g_ppu8Init) / 2; ++i) sccbWriteReg(**(g_ppu8Init + i), *(*(g_ppu8Init + i) + 1));
    return CAM_ERR_OK;
}

void camSetImageMode(camImageMode camimParam) {
    uint8_t i;
    switch (camimParam) {
    case IMAGE_MODE_RGB565:
        for (i = 0; i < sizeof(g_ppu8RGB565) / 2; ++i) sccbWriteReg(**(g_ppu8RGB565 + i), *(*(g_ppu8RGB565 + i) + 1));
        break;
    case IMAGE_MODE_JPEG:
        for (i = 0; i < sizeof(g_ppu8YUV422) / 2; ++i) sccbWriteReg(**(g_ppu8YUV422 + i), *(*(g_ppu8YUV422 + i) + 1));
        for (i = 0; i < sizeof(g_ppu8JPEG) / 2; ++i) sccbWriteReg(**(g_ppu8JPEG + i), *(*(g_ppu8JPEG + i) + 1));
        break;
    }
}

void camSetWindow(uint16_t x, uint16_t y, uint16_t width, uint16_t height) {
    width = x + width / 2, height = y + height / 2;
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x1);
    sccbWriteReg(OV2640_SENSOR_COM1, (sccbReadReg(OV2640_SENSOR_COM1) & 0xF0) | (height & 0x3) << 2 | (y & 0x3));
    sccbWriteReg(OV2640_SENSOR_VSTART, y >> 2);
    sccbWriteReg(OV2640_SENSOR_VEND, height >> 2);
    sccbWriteReg(OV2640_SENSOR_REG32, (sccbReadReg(OV2640_SENSOR_REG32) & 0xC0) | (width & 0x7) << 3 | (x & 0x7));
    sccbWriteReg(OV2640_SENSOR_HSTART, x >> 3);
    sccbWriteReg(OV2640_SENSOR_HEND, width >> 3);
}

void camSetSize(uint16_t width, uint16_t height) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_RESET, 0x4);
    sccbWriteReg(OV2640_DSP_HSIZE2, width >> 3 & 0xFF);
    sccbWriteReg(OV2640_DSP_VSIZE2, height >> 3 & 0xFF);
    sccbWriteReg(OV2640_DSP_SIZEL, (width >> 4 & 0x80) | (width & 0x7) << 3 | (height & 0x7));
    sccbWriteReg(OV2640_DSP_RESET, 0x0);
}

cam_err_e camSetImageWindow(uint16_t x, uint16_t y, uint16_t width, uint16_t height) {
    if (width % 4 || height % 4) return CAM_ERR_NOT_DIVIDED_BY_4;
    width /= 4, height /= 4;
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_RESET, 0x4);
    sccbWriteReg(OV2640_DSP_HSIZE1, width & 0xFF);
    sccbWriteReg(OV2640_DSP_VSIZE1, height & 0xFF);
    sccbWriteReg(OV2640_DSP_XOFFL, x & 0xFF);
    sccbWriteReg(OV2640_DSP_YOFFL, y & 0xFF);
    sccbWriteReg(OV2640_DSP_VHYX, (height >> 1 & 0x80) | (y >> 4 & 0x70) | (width >> 5 & 0x8) | (x >> 8 & 0x7));
    sccbWriteReg(OV2640_DSP_TEST, width >> 2 & 0x80);
    sccbWriteReg(OV2640_DSP_RESET, 0x0);
    return CAM_ERR_OK;
}

cam_err_e camSetImageSize(uint16_t width, uint16_t height) {
    if (width % 4 || height % 4) return CAM_ERR_NOT_DIVIDED_BY_4;
    width /= 4, height /= 4;
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_RESET, 0x4);
    sccbWriteReg(OV2640_DSP_ZMOW, width & 0xFF);
    sccbWriteReg(OV2640_DSP_ZMOH, height & 0xFF);
    sccbWriteReg(OV2640_DSP_ZMHH, (height >> 6 & 0x4) | (width >> 8 & 0x3));
    sccbWriteReg(OV2640_DSP_RESET, 0x0);
    return CAM_ERR_OK;
}

void camSetAutoExposure(camAutoExposure camaeParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x1);
    uint8_t *pu8Param = (uint8_t *)*(g_ppu8AutoExposure + camaeParam);
    for (uint8_t i = 0; i < 3; ++i) sccbWriteReg(*(pu8Param + i * 2), *(pu8Param + i * 2 + 1));
}

void camSetWhiteBalance(camWhiteBalance camwbParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(0xC7, camwbParam != WHITE_BALANCE_AUTO ? 0x40 : 0x10);
    if (camwbParam-- != WHITE_BALANCE_AUTO) {
        uint8_t *pu8Param = (uint8_t *)*(g_ppu8WhiteBalance + camwbParam);
        for (uint8_t i = 0; i < 3; ++i) sccbWriteReg(*(pu8Param + i * 2), *(pu8Param + i * 2 + 1));
    }
}

void camSetSaturation(camIncValue camivParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x0);
    sccbWriteReg(OV2640_DSP_BPDATA, 0x2);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x3);
    sccbWriteReg(OV2640_DSP_BPDATA, (camivParam + 2) << 4 | 0x8);
    sccbWriteReg(OV2640_DSP_BPDATA, (camivParam + 2) << 4 | 0x8);
}

void camSetBrightness(camIncValue camivParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x0);
    sccbWriteReg(OV2640_DSP_BPDATA, 0x4);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x9);
    sccbWriteReg(OV2640_DSP_BPDATA, camivParam << 4);
    sccbWriteReg(OV2640_DSP_BPDATA, 0x0);
}

void camSetContrast(camIncValue camivParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x0);
    sccbWriteReg(OV2640_DSP_BPDATA, 0x4);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x7);
    sccbWriteReg(OV2640_DSP_BPDATA, 0x20);
    sccbWriteReg(OV2640_DSP_BPDATA, **(g_ppu8Contrast + camivParam));
    sccbWriteReg(OV2640_DSP_BPDATA, *(*(g_ppu8Contrast + camivParam) + 1));
    sccbWriteReg(OV2640_DSP_BPDATA, 0x6);
}

void camSetEffect(camEffect cameParam) {
    sccbWriteReg(OV2640_DSP_RA_DLMT, 0x0);
    sccbWriteReg(OV2640_DSP_BPADDR, 0x0);
    sccbWriteReg(OV2640_DSP_BPDATA, **(g_ppu8Effect + cameParam));
    sccbWriteReg(OV2640_DSP_BPADDR, 0x5);
    sccbWriteReg(OV2640_DSP_BPDATA, *(*(g_ppu8Effect + cameParam) + 1));
    sccbWriteReg(OV2640_DSP_BPDATA, *(*(g_ppu8Effect + cameParam) + 2));
}
